# -*- coding: utf-8 -*-
"""Neural-Color-Formulation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XkWb45LDG7esqJdjuMjt_7hCwD5ZPwuY
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from sklearn.model_selection import train_test_split
from tensorflow.keras.layers import Input

# 1. MODELADO FÍSICO-QUÍMICO (TEORÍA KUBELKA-MUNK)

class Pigmento:
    """
    Representación digital de las propiedades ópticas de un material.
    Almacena los coeficientes de absorción (K) y dispersión (S) espectrales.
    """
    def __init__(self, nombre, k_rgb, s_rgb):
        self.nombre = nombre
        self.k = np.array(k_rgb) # Coeficiente de Absorción (K)
        self.s = np.array(s_rgb) # Coeficiente de Dispersión (S)

# Inicialización del inventario de materias primas
base_blanca = Pigmento("Blanco (TiO2)", k_rgb=[0.01, 0.01, 0.01], s_rgb=[1.0, 1.0, 1.0])
pigmento_rojo = Pigmento("Rojo", k_rgb=[0.05, 0.8, 0.8], s_rgb=[0.5, 0.1, 0.1])
pigmento_azul = Pigmento("Azul", k_rgb=[0.8, 0.8, 0.05], s_rgb=[0.1, 0.1, 0.5])
pigmento_amarillo = Pigmento("Amarillo", k_rgb=[0.05, 0.05, 0.9], s_rgb=[0.5, 0.5, 0.1])

lista_pigmentos = [base_blanca, pigmento_rojo, pigmento_azul, pigmento_amarillo]

def calcular_reflectancia_teorica(concentraciones):
    """
    Calcula la reflectancia espectral (R) de una mezcla basada en la Ley de Mezclas
    y la ecuación de Kubelka-Munk: K/S = (1-R)^2 / 2R.
    """
    k_total = 0
    s_total = 0

    # Sumatoria ponderada de coeficientes K y S según concentración másica
    for i, pigmento in enumerate(lista_pigmentos):
        cantidad = concentraciones[i]
        k_total += cantidad * pigmento.k
        s_total += cantidad * pigmento.s

    # Resolución inversa de la ecuación K-M para obtener Reflectancia (R)
    ratio_ks = k_total / s_total
    reflectancia = 1 + ratio_ks - np.sqrt(ratio_ks**2 + 2 * ratio_ks)

    return reflectancia

def rgb_a_cielab(rgb):
    """
    Transformación del espacio de color RGB lineal al espacio perceptual CIELAB.
    Utiliza una aproximación no lineal (raíz cúbica) para simular la respuesta
    del ojo humano.
    """
    r, g, b = rgb
    # Conversión aproximada a coordenadas L*a*b*
    L = 116 * (g**(1/3)) - 16
    a_val = 500 * ((r**(1/3)) - (g**(1/3)))
    b_val = 200 * ((g**(1/3)) - (b**(1/3)))

    return np.array([L, a_val, b_val])

# 2. GENERACIÓN DE DATASET SINTÉTICO

print("Iniciando simulación de Monte Carlo para generar dataset (N=100,000)...")

datos_input = []  # X: Concentraciones (Fórmula)
datos_output = [] # Y: Color Resultante (Propiedad)

NUM_MUESTRAS = 100000

for _ in range(NUM_MUESTRAS):
    # Generación estocástica de fórmulas usando distribución exponencial
    # para simular formulaciones industriales típicas (base dominante + tintes).
    concentraciones = np.random.exponential(scale=1.0, size=4)

    # Normalización porcentual (suma = 100%)
    concentraciones = (concentraciones / concentraciones.sum()) * 100

    # Simulación del fenómeno físico
    rgb_teorico = calcular_reflectancia_teorica(concentraciones)
    lab_final = rgb_a_cielab(rgb_teorico)

    datos_input.append(concentraciones)
    datos_output.append(lab_final)

# Estructuración de datos
df_recetas = pd.DataFrame(datos_input, columns=["Blanco_g", "Rojo_g", "Azul_g", "Amarillo_g"])
df_colores = pd.DataFrame(datos_output, columns=["L", "a", "b"])
dataset_completo = pd.concat([df_recetas, df_colores], axis=1)

print("Dataset generado exitosamente.")

# 3. ENTRENAMIENTO DE LA RED NEURONAL INVERSA

# Definición de variables para el problema inverso:
# Entrada: Propiedad Deseada (Color LAB) -> Salida: Formulación (Receta)
X = df_colores.values / 100.0 # Normalización [0, 1]
y = df_recetas.values / 100.0 # Normalización [0, 1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Arquitectura de Red Neuronal Densa (DNN)
model = Sequential()
model.add(Input(shape=(3,)))
model.add(Dense(64, activation='relu'))              # Capa de entrada (L, a, b)
model.add(Dense(128, activation='relu'))             # Capas ocultas para modelar no-linealidad K-M
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.1))                              # Regularización
model.add(Dense(4, activation='softmax'))            # Salida con restricción de suma unitaria (Softmax)

model.compile(optimizer='adam', loss='mse')

print("Iniciando entrenamiento del modelo predictivo...")
history = model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0, validation_split=0.1)
print(f"Entrenamiento finalizado. Validation Loss: {history.history['val_loss'][-1]:.2e}")

# 4. VALIDACIÓN DE LAZO CERRADO

# Definición del Target (Color Objetivo/ Pedido del cliente: Rosa Pastel)
target_lab = np.array([[80, 20, 0]])
input_vector = target_lab / 100.0

# Inferencia del Modelo (Predicción de Fórmula)
receta_predicha = model.predict(input_vector, verbose=0) * 100
receta_vector = receta_predicha[0]

# Verificación Física: Re-introducir la receta predicha en el simulador físico
rgb_verificacion = calcular_reflectancia_teorica(receta_vector)
lab_obtenido = rgb_a_cielab(rgb_verificacion)

# Cálculo de la Métrica de Error Industrial (Delta E)
# Distancia Euclidiana en el espacio de color L*a*b*
delta_e = np.sqrt(np.sum((target_lab[0] - lab_obtenido)**2))

print("\n--- REPORTE DE VALIDACIÓN TÉCNICA ---")
print(f"Objetivo (LAB): {target_lab[0]}")
print(f"Resultado (LAB): {lab_obtenido}")
print(f"Fórmula Sugerida: {receta_vector}")
print(f"Precisión del Modelo (Delta E): {delta_e:.4f}")

if delta_e < 1.0:
    print(">> ESTADO: ÓPTIMO. Diferencia imperceptible para el ojo humano estándar.")
else:
    print(">> ESTADO: DESVIACIÓN DETECTADA. Se requiere ajuste fino.")
